1.

#include <GL/glut.h>
#include <stdio.h>

int x1, y1, x2, y2;

void myInit()
{
	glClear(GL_COLOR_BUFFER_BIT);
	glClearColor(0.0, 0.0, 0.0, 1.0);
	glMatrixMode(GL_PROJECTION);
	gluOrtho2D(0, 500, 0, 500);
}

void draw_pixel(int x, int y) 
{
	glBegin(GL_POINTS);
	glVertex2i(x, y);
	glEnd();
}


void draw_line(int x1, int x2, int y1, int y2) 
{
	int dx, dy, i, e;
	int incx, incy, inc1, inc2;
	int x,y;

	dx = x2-x1;
	dy = y2-y1;
	
	if (dx < 0) 
		dx = -dx;
	if (dy < 0) 
		dy = -dy;
	
	incx = 1;
	
	if (x2 < x1) 
		incx = -1;

	incy = 1;
	
	if (y2 < y1) 
		incy = -1;
		
	x = x1; y = y1;
	
	if (dx > dy) 
	{
		draw_pixel(x, y);
		e = 2 * dy-dx;
		inc1 = 2*(dy-dx); // when e >= 0
		inc2 = 2*dy;	 // when e < 0
		for (i=0; i<dx; i++) 
		{
			if (e >= 0) 
			{
				y += incy;
				e += inc1;
			}
			else
			{
				e += inc2;
			}	
			x += incx;
			draw_pixel(x, y);
		}
	}
	else 
	{
		draw_pixel(x, y);
		e = 2*dx-dy;
		inc1 = 2*(dx-dy);    // when e >= 0
		inc2 = 2*dx;         // when e < 0
		for (i=0; i<dy; i++) 
		{
			if (e >= 0) 
			{
				x += incx;
				e += inc1;
			}
			else
			{
				e += inc2;
			}
				
			y += incy;
			draw_pixel(x, y);
		}
	}
}

void myDisplay() 
{
	draw_line(x1, x2, y1, y2);
	glFlush();
}


int main(int argc, char **argv) 
{
	printf( "Enter (x1, y1, x2, y2)\n");
	scanf("%d %d %d %d", &x1, &y1, &x2, &y2);
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);
	glutInitWindowSize(300, 300);
	glutInitWindowPosition(100, 100);
	glutCreateWindow("Bresenham's Line Drawing");
	myInit();
	glutDisplayFunc(myDisplay);
	glutMainLoop();
	return 0;
}


--------------------------------------------------------------------------------------------------------
2.
#include <GL/glut.h>
#include <stdio.h>

int x=0, y=0;
float theta=0.0f;

void myInit()
{
	
	glClearColor(1.0, 1.0, 1.0, 1.0);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(-300, 300, -300, 300);
	glMatrixMode(GL_MODELVIEW);
	
}

void draw_triangle() 
{
  glBegin(GL_POLYGON);
		glVertex2i(0, 0);
		glVertex2i(100, 100);
		glVertex2i(200, 0);
	glEnd();
}

void myDisplay() 
{
	glClear(GL_COLOR_BUFFER_BIT);
	
	glColor3f(1.0, 0.0, 0.0);
	//glViewport(0, 300, 300, 300);
	glPushMatrix();
	draw_triangle();
	glFlush();
	glPopMatrix();
	
	glColor3f(0.0, 1.0, 0.0);
	//glViewport(0, 0, 300, 300);
	glPushMatrix();
	glRotatef(theta, 0.0, 0.0, 1.0);
	draw_triangle();
	glFlush();
	glPopMatrix(); 
	
	
	glColor3f(0.0, 0.0, 1.0);
	//glViewpo rt(300, 0, 300, 300);
	glPushMatrix();
	glTranslatef((float)x, (float)y, 0);
	glRotatef(theta, 0.0, 0.0, 1.0);
	glTranslatef((float)-x, (float)-y, 0);
	draw_triangle();
	glFlush();
	glPopMatrix();
}


int main(int argc, char **argv) 
{
	printf( "Enter the angle");
	scanf("%f", &theta);
	printf( "Enter the fixed point (x, y)");
	scanf("%d %d", &x, &y);
	
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);
	glutInitWindowSize(600, 600);
	glutInitWindowPosition(100, 100);
	glutCreateWindow("Rotating a Triangle");
	myInit();
	glutDisplayFunc(myDisplay);
	glutMainLoop();
	return 0;
}
--------------------------------------------------------------------------------------------------
3.
#include <stdio.h>
#include <stdlib.h>
#include<GL/glut.h>

GLfloat vertices[ ]={ 	-1.0,-1.0,-1.0,
								1.0,-1.0,-1.0,
								1.0, 1.0,-1.0,
							- 1.0, 1.0,-1.0,
							- 1.0,-1.0, 1.0,
								1.0,-1.0, 1.0,
								1.0, 1.0, 1.0,
							-1.0, 1.0, 1.0 
					};
					
GLfloat normals[ ]={ 	-1.0,-1.0,-1.0,
								1.0,-1.0,-1.0,
								1.0, 1.0,-1.0,
								-1.0, 1.0,-1.0,
								-1.0,-1.0, 1.0,
								1.0,-1.0, 1.0,
								1.0, 1.0, 1.0,
								-1.0, 1.0, 1.0 
						};
						
GLfloat colors[ ]={	0.0,0.0,0.0,
							1.0,0.0,0.0,
							1.0,1.0,0.0,
							0.0,1.0,0.0,
							0.0,0.0,1.0,
							1.0,0.0,1.0,
							1.0,1.0,1.0,
							0.0,1.0,1.0
					};
					
GLubyte cubeIndices[]={	0,3,2,1,
								2,3,7,6,
								0,4,7,3,
								1,2,6,5,
								4,5,6,7,
								0,1,5,4 
						};
						
static GLfloat theta[]={0.0,0.0,0.0};
static GLint axis=2;


void display(void)
{
	glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
	glLoadIdentity();
	glRotatef(theta[0],1.0,0.0,0.0);
	glRotatef(theta[1],0.0,1.0,0.0);
	glRotatef(theta[2],0.0,0.0,1.0);
	glDrawElements(GL_QUADS,24,GL_UNSIGNED_BYTE,cubeIndices);
	glFlush();
	glutSwapBuffers();
}


void mouse(int btn,int state,int x,int y)
{
	if(btn==GLUT_LEFT_BUTTON && state==GLUT_DOWN)   axis=0;
	if(btn==GLUT_RIGHT_BUTTON && state==GLUT_DOWN)  axis=1;
	if(btn==GLUT_MIDDLE_BUTTON && state==GLUT_DOWN) axis=2;
}


void spincube()
{
	theta[axis]+=2.0;
	if(theta[axis]>360.0)
		theta[axis]-=360.0;
	glutPostRedisplay();
}


void myReshape(int w,int h)
{
	glViewport(0,0,w,h);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if(w<=h)
		glOrtho(-2.0,2.0,-2.0*(GLfloat)h/(GLfloat)w,2.0*(GLfloat)h/(GLfloat)w,10.0,10.0);
	else
		glOrtho(-2.0*(GLfloat)w/(GLfloat)h,2.0*(GLfloat)w/(GLfloat)h,-2.0,2.0,-10.0,10.0);
	glMatrixMode(GL_MODELVIEW);
}


int main(int argc,char **argv)
{
	glutInit(&argc,argv);
	glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB|GLUT_DEPTH);
	glutInitWindowSize(900,900);
	glutCreateWindow("color cuce");
	glutReshapeFunc(myReshape);
	glutDisplayFunc(display);
	glutMouseFunc(mouse);
	glutIdleFunc(spincube);
	glEnable(GL_DEPTH_TEST);
	glEnableClientState(GL_COLOR_ARRAY);
	glEnableClientState(GL_VERTEX_ARRAY);
	glEnableClientState(GL_NORMAL_ARRAY);
	glVertexPointer(3,GL_FLOAT,0,vertices);
	glColorPointer(3,GL_FLOAT,0,colors);
	glNormalPointer(GL_FLOAT,0,normals);
	glColor3f(1.0,1.0,1.0);
	glutMainLoop();
}
------------------------------------------------------------------------------------------
4.
#include <stdlib.h>
#include <GL/glut.h>

GLfloat vertices[][3] = {	{-1,-1,-1}, {1,-1,-1},
							{1,1,-1},   {-1,1,-1},
							{-1,-1,1},  {1,-1,1}, 
							{1,1,1},    {-1,1,1}
						};
						
GLfloat colors[][3] = {	{1,0,0},{1,1,0},
						{0,1,0},{0,0,1},
						{1,0,1},{1,1,1},
						{0,1,1},{0.5,0.5,0.5}
					};
					
					
void polygon(int a, int b, int c , int d)
{
	glBegin(GL_POLYGON);
		glColor3fv(colors[a]);
		glVertex3fv(vertices[a]);
		glColor3fv(colors[b]);
		glVertex3fv(vertices[b]);
		glColor3fv(colors[c]);
		glVertex3fv(vertices[c]);
		glColor3fv(colors[d]);
		glVertex3fv(vertices[d]);
		glEnd();
}


void colorcube(void)
{
	polygon(0,3,2,1);
	polygon(0,4,7,3);
	polygon(5,4,0,1);
	polygon(2,3,7,6);
	polygon(1,2,6,5);
	polygon(4,5,6,7);
}


GLfloat theta[] = {0.0,0.0,0.0};
GLint axis = 2;
GLdouble viewer[]= {0.0, 0.0, 5.0}; /* initial viewer location */


void display(void)
{
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glLoadIdentity();
	gluLookAt(viewer[0],viewer[1],viewer[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
	glRotatef(theta[0], 1.0, 0.0, 0.0);
	glRotatef(theta[1], 0.0, 1.0, 0.0);
	glRotatef(theta[2], 0.0, 0.0, 1.0);
	colorcube();
	glFlush();
	glutSwapBuffers();
}


void mouse(int btn, int state, int x, int y)
{
	if(btn==GLUT_LEFT_BUTTON && state == GLUT_DOWN) axis = 0;
	if(btn==GLUT_MIDDLE_BUTTON && state == GLUT_DOWN) axis = 1;
	if(btn==GLUT_RIGHT_BUTTON && state == GLUT_DOWN) axis = 2;
	
	theta[axis] += 2.0;
	if( theta[axis] > 360.0 ) theta[axis] -= 360.0;
	display();
}


void keys(unsigned char key, int x, int y)
{
	if(key == 'x') viewer[0]-= 1.0;
	if(key == 'X') viewer[0]+= 1.0;
	if(key == 'y') viewer[1]-= 1.0;
	if(key == 'Y') viewer[1]+= 1.0;
	if(key == 'z') viewer[2]-= 1.0;
	if(key == 'Z') viewer[2]+= 1.0;
	display();
}





void myReshape(int w, int h)
{
	glViewport(0, 0, w, h);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	
	if(w<=h)
		glFrustum(-2.0, 2.0, -2.0 * (GLfloat) h/ (GLfloat) w, 2.0* (GLfloat) h /
			(GLfloat) w,2.0, 20.0);
	else
		glFrustum(-2.0, 2.0, -2.0 * (GLfloat) w/ (GLfloat) h, 2.0* (GLfloat) w /
			(GLfloat) h, 2.0, 20.0);
			
	glMatrixMode(GL_MODELVIEW);
}

int main(int argc, char **argv) 
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
	glutInitWindowSize(500, 500);
	glutCreateWindow("Colorcube Viewer");
	glutReshapeFunc(myReshape);
	glutDisplayFunc(display);
	glutMouseFunc(mouse);
	glutKeyboardFunc(keys);
	glEnable(GL_DEPTH_TEST);
	glutMainLoop();
	return 0;
}
-----------------------------------------------------------------------------------
7.
#include <GL/glut.h>
#include<stdlib.h>
#include<stdio.h>

typedef float point[3];

point v[ ]={{0.0,0.0,1.0}, {0.0, 0.9, -0.3}, {-0.8, -0.4, -0.3}, {0.8, -0.4, 0.3}};

static GLfloat theta[ ]={0.0,0.0,0.0};
int n;

void triangle(point a, point b, point c)
{
	glBegin(GL_POLYGON);
		glVertex3fv(a);
		glVertex3fv(b);
		glVertex3fv(c);
	glEnd();
}

void divide_triangle(point a, point b, point c, int m)
{
	point v1, v2, v3;
	int j;
	
	if(m>0)
	{
		for(j=0; j<3; j++)
		{
			v1[j]=(a[j]+b[j])/2;
			v2[j]=(a[j]+c[j])/2;
			v3[j]=(b[j]+c[j])/2;
		}
		divide_triangle(a, v1, v2, m-1);
		divide_triangle(b, v1, v3, m-1);
		divide_triangle(c, v2, v3, m-1);
	}
	else
		triangle(a, b, c);
}


void tetrahedron(int m)
{
	glColor3f(1.0, 0.0, 0.0);
	divide_triangle(v[0], v[1 ], v[2], m);
	glColor3f(0.0, 0.0, 1.0);
	divide_triangle(v[0], v[1], v[3], m);
	glColor3f(0.0, 0.0, 0.0);
	divide_triangle(v[0], v[2], v[3], m);
	glColor3f(0.0, 1.0, 0.0);
	divide_triangle(v[1], v[2], v[3], m);
}


void display(void)
{
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glLoadIdentity();
	tetrahedron(n);
	glFlush();
}


void myinit()
{
	glClearColor(1.0, 1.0, 1.0, 1.0);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-2.0, 2.0, -2.0, 2.0, -5.0, 5.0);
	glMatrixMode(GL_MODELVIEW); 
}


int main(int argc, char **argv)
{
	printf("No. of Divisions ? \n");
	scanf("%d", &n);
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);
	glutInitWindowSize(500, 500);
	glutCreateWindow("3D Gasket");
	myinit();
	glutDisplayFunc(display);
	glEnable(GL_DEPTH_TEST);
	glutMainLoop();
}
-----------------------------------------------------------------------------------
9.

#include <GL/glut.h>

float x1,x2,x3,x4,y1,y2,y3,y4;

GLfloat red=1.0, green=1.0, blue=0.0;

void edgedetect(float x1,float y1,float x2,float y2,int *le,int *re)
{
	float mx,x,temp;
	int i;
	
	if((y2-y1)<0)
	{
		temp=y1;  y1=y2;  y2=temp;
		temp=x1;  x1=x2;  x2=temp;
	}
	
	if((y2-y1)!=0)
		mx=(x2-x1)/(y2-y1);
	else
		mx=x2-x1;
	
	x=x1;
	
	for(i=y1;i<=y2;i++)
	{
		if(x<(float)le[i])
			le[i]=(int)x;
		if(x>(float)re[i])
			re[i]=(int)x;
		x+=mx;
	}
}


void draw_pixel(int x,int y)
{
	glColor3f(red, green, blue);
	glBegin(GL_POINTS);
		glVertex2i(x,y);
	glEnd();
}


void scanfill(float x1,float y1,float x2,float y2,float x3,float y3,float x4,float y4)
{
	int le[500],re[500];
	int i,y;
	for(i=0;i<500;i++)
	{
		le[i]=500;
		re[i]=0;
	}
	edgedetect(x1,y1,x2,y2,le,re);
	edgedetect(x2,y2,x3,y3,le,re);
	edgedetect(x3,y3,x4,y4,le,re);
	edgedetect(x4,y4,x1,y1,le,re);
	for(y=0;y<500;y++)
	{
		if(le[y]<=re[y])
			for(i=(int)le[y];i<(int)re[y];i++)
				draw_pixel(i,y);
	}
}


void display()
{
	x1=200.0;  y1=200.0;
	x2=100.0;  y2=300.0; 
	x3=200.0;  y3=400.0;
	x4=300.0;  y4=300.0;
	
	glClear(GL_COLOR_BUFFER_BIT);
	
	/*
	glBegin(GL_LINE_LOOP);
		glVertex2f(x1,y1);
		glVertex2f(x2,y2);
		glVertex2f(x3,y3);
		glVertex2f(x4,y4);
	glEnd();  */
	
	scanfill(x1,y1,x2,y2,x3,y3,x4,y4);
	glFlush();
}


void myinit()
{
	glClearColor(1.0,1.0,1.0,1.0);
	glColor3f(1.0,0.0,0.0);
	glPointSize(1.0);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0.0,499.0,0.0,499.0);
}
void menu(GLint option)
{
	switch(option)
	{
		case 1: red=1.0; green=0.0; blue=0.0;
					break;
		
		case 2: red=0.0; green=1.0; blue=0.0;
					break;
		
		
		case 3: red=0.0; green=0.0; blue=1.0;
					break;
	
	}
	glutPostRedisplay();
}

int main(int argc, char** argv)
{
	glutInit(&argc,argv);
	glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);
	glutInitWindowSize(500,500);
	glutInitWindowPosition(0,0);
	glutCreateWindow("Filling a Polygon using Scan-line Algorithm");
	glutDisplayFunc(display);
	glutCreateMenu(menu);
	glutAddMenuEntry("RED", 1);
	glutAddMenuEntry("GREEN", 2);
	glutAddMenuEntry("BLUE", 3);
	glutAttachMenu(GLUT_RIGHT_BUTTON);
	myinit();
	glutMainLoop();
	return 0;
}

